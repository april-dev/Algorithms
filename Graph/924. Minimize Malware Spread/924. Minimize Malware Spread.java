/**
Union found all nodes.
Count the union size of each union set.
Count the malware number of each union set.

Return the biggest union's malware if there is one and only one malware.
If no such union that has and has only one malware,
return the malware with minimum index.

Time Complexity:
O(N^2)
*/

private int[] p;

    public int minMalwareSpread(int[][] g, int[] initial) {
        int n = g.length;
        p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);
        int[] ufSize = new int[n];
        int[] malCount = new int[n];
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        for (int init : initial) malCount[find(init)]++;
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }

    private void union(int i, int j) {
        p[find(i)] = find(j);
    }

    private int find(int i) {
        if (p[i] == i) return i;
        else {
            p[i] = find(p[i]);
            return p[i];
        }
    }
